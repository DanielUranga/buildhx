<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>easeljs&#x2F;display&#x2F;Graphics.js</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Bitmap.html">Bitmap</a></li>
            
                <li><a href="..&#x2F;classes/BitmapAnimation.html">BitmapAnimation</a></li>
            
                <li><a href="..&#x2F;classes/BoxBlurFilter.html">BoxBlurFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorFilter.html">ColorFilter</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrix.html">ColorMatrix</a></li>
            
                <li><a href="..&#x2F;classes/ColorMatrixFilter.html">ColorMatrixFilter</a></li>
            
                <li><a href="..&#x2F;classes/Command.html">Command</a></li>
            
                <li><a href="..&#x2F;classes/Container.html">Container</a></li>
            
                <li><a href="..&#x2F;classes/DisplayObject.html">DisplayObject</a></li>
            
                <li><a href="..&#x2F;classes/DOMElement.html">DOMElement</a></li>
            
                <li><a href="..&#x2F;classes/FBBitmapAnimation.html">FBBitmapAnimation</a></li>
            
                <li><a href="..&#x2F;classes/Filter.html">Filter</a></li>
            
                <li><a href="..&#x2F;classes/Graphics.html">Graphics</a></li>
            
                <li><a href="..&#x2F;classes/Matrix2D.html">Matrix2D</a></li>
            
                <li><a href="..&#x2F;classes/MouseEvent.html">MouseEvent</a></li>
            
                <li><a href="..&#x2F;classes/MovieClip.html">MovieClip</a></li>
            
                <li><a href="..&#x2F;classes/MovieClipPlugin.html">MovieClipPlugin</a></li>
            
                <li><a href="..&#x2F;classes/Point.html">Point</a></li>
            
                <li><a href="..&#x2F;classes/Rectangle.html">Rectangle</a></li>
            
                <li><a href="..&#x2F;classes/Shadow.html">Shadow</a></li>
            
                <li><a href="..&#x2F;classes/Shape.html">Shape</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheet.html">SpriteSheet</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetBuilder.html">SpriteSheetBuilder</a></li>
            
                <li><a href="..&#x2F;classes/SpriteSheetUtils.html">SpriteSheetUtils</a></li>
            
                <li><a href="..&#x2F;classes/Stage.html">Stage</a></li>
            
                <li><a href="..&#x2F;classes/Text.html">Text</a></li>
            
                <li><a href="..&#x2F;classes/Ticker.html">Ticker</a></li>
            
                <li><a href="..&#x2F;classes/Touch.html">Touch</a></li>
            
                <li><a href="..&#x2F;classes/UID.html">UID</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/EaselJS.html">EaselJS</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: easeljs&#x2F;display&#x2F;Graphics.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;*
* Graphics
* Visit http:&#x2F;&#x2F;createjs.com&#x2F; for documentation, updates and examples.
*
* Copyright (c) 2010 gskinner.com, inc.
* 
* Permission is hereby granted, free of charge, to any person
* obtaining a copy of this software and associated documentation
* files (the &quot;Software&quot;), to deal in the Software without
* restriction, including without limitation the rights to use,
* copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell
* copies of the Software, and to permit persons to whom the
* Software is furnished to do so, subject to the following
* conditions:
* 
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
* 
* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
* OTHER DEALINGS IN THE SOFTWARE.
*&#x2F;

(function(window) {

&#x2F;&#x2F; used to create the instruction lists used in Graphics:


&#x2F;**
* Inner class used by the Graphics class. Used to create the instruction lists used in Graphics:
* @class Command
* @for Graphics
* @constructor
**&#x2F;
function Command(f, params, path) {
	this.f = f;
	this.params = params;
	this.path = path==null ? true : path;
}

&#x2F;**
* @method exec
* @param {Object} scope
**&#x2F;
Command.prototype.exec = function(scope) { this.f.apply(scope, this.params); }

&#x2F;**
* The Graphics class exposes an easy to use API for generating vector drawing instructions and drawing them to a specified context.
* Note that you can use Graphics without any dependency on the Easel framework by calling draw() directly,
* or it can be used with the Shape object to draw vector graphics within the context of an Easel display list.&lt;br&#x2F;&gt;&lt;br&#x2F;&gt;
* &lt;pre&gt;&lt;code&gt;var g = new Graphics();
*	g.setStrokeStyle(1);
*	g.beginStroke(Graphics.getRGB(0,0,0));
*	g.beginFill(Graphics.getRGB(255,0,0));
*	g.drawCircle(0,0,3);
*
*	var s = new Shape(g);
*		s.x = 100;
*		s.y = 100;
*
*	stage.addChild(s);
*	stage.update();&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;&lt;br &#x2F;&gt;
* Note that all drawing methods in Graphics return the Graphics instance, so they can be chained together. For example, the following 
* line of code would generate the instructions to draw a rectangle with a red stroke and blue fill, then render it to the specified 
* context2D:&lt;br &#x2F;&gt;
* &lt;pre&gt;&lt;code&gt;myGraphics.beginStroke(&quot;#F00&quot;).beginFill(&quot;#00F&quot;).drawRect(20, 20, 100, 50).draw(myContext2D);
* @class Graphics
* @constructor
* @for Graphics
**&#x2F;
var Graphics = function() {
	this.initialize();
}
var p = Graphics.prototype;

&#x2F;&#x2F; static public methods:
	
	
	&#x2F;**
	 * Returns a CSS compatible color string based on the specified RGB numeric color values in the format 
	 * &quot;rgba(255,255,255,1.0)&quot;, or if alpha is null then in the format &quot;rgb(255,255,255)&quot;. For example,
	 * Graphics.getRGB(50, 100, 150, 0.5) will return &quot;rgba(50,100,150,0.5)&quot;. It also supports passing a single hex color 
	 * value as the first param, and an optional alpha value as the second param. For example, Graphics.getRGB(0xFF00FF, 0.2)
	 * will return &quot;rgba(255,0,255,0.2)&quot;.
	 * @method getRGB
	 * @static
	 * @param {Number} r The red component for the color, between 0 and 0xFF (255).
	 * @param {Number} g The green component for the color, between 0 and 0xFF (255).
	 * @param {Number} b The blue component for the color, between 0 and 0xFF (255).
	 * @param {Number} alpha Optional. The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return A CSS compatible color string based on the specified RGB numeric color values in the format 
	 * &quot;rgba(255,255,255,1.0)&quot;, or if alpha is null then in the format &quot;rgb(255,255,255)&quot;.
	 **&#x2F;
	Graphics.getRGB = function(r, g, b, alpha) {
		if (r != null &amp;&amp; b == null) {
			alpha = g;
			b = r&amp;0xFF;
			g = r&gt;&gt;8&amp;0xFF;
			r = r&gt;&gt;16&amp;0xFF;
		}
		if (alpha == null) {
			return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;;
		} else {
			return &quot;rgba(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;,&quot;+alpha+&quot;)&quot;;
		}
	}
	
	&#x2F;**
	 * Returns a CSS compatible color string based on the specified HSL numeric color values in the format &quot;hsla(360,100,100,1.0)&quot;, 
	 * or if alpha is null then in the format &quot;hsl(360,100,100)&quot;. For example, Graphics.getHSL(150, 100, 70) will return 
	 * &quot;hsl(150,100,70)&quot;.
	 * @method getHSL
	 * @static
	 * @param {Number} hue The hue component for the color, between 0 and 360.
	 * @param {Number} saturation The saturation component for the color, between 0 and 100.
	 * @param {Number} lightness The lightness component for the color, between 0 and 100.
	 * @param {Number} alpha Optional. The alpha component for the color where 0 is fully transparent and 1 is fully opaque.
	 * @return a CSS compatible color string based on the specified HSL numeric color values in the format 
	 * &quot;hsla(360,100,100,1.0)&quot;, or if alpha is null then in the format &quot;hsl(360,100,100)&quot;. For example, 
	 * Graphics.getHSL(150, 100, 70) will return &quot;hsl(150,100,70)&quot;.
	 **&#x2F;
	Graphics.getHSL = function(hue, saturation, lightness, alpha) {
		if (alpha == null) {
			return &quot;hsl(&quot;+(hue%360)+&quot;,&quot;+saturation+&quot;%,&quot;+lightness+&quot;%)&quot;;
		} else {
			return &quot;hsla(&quot;+(hue%360)+&quot;,&quot;+saturation+&quot;%,&quot;+lightness+&quot;%,&quot;+alpha+&quot;)&quot;;
		}
	}
	
	&#x2F;**
	 * Map of Base64 characters to values. Used by decodePath().
	 * @property BASE_64
	 * @static
	 * @final
	 * @type Object
	 **&#x2F;
	Graphics.BASE_64 = {&quot;A&quot;:0,&quot;B&quot;:1,&quot;C&quot;:2,&quot;D&quot;:3,&quot;E&quot;:4,&quot;F&quot;:5,&quot;G&quot;:6,&quot;H&quot;:7,&quot;I&quot;:8,&quot;J&quot;:9,&quot;K&quot;:10,&quot;L&quot;:11,&quot;M&quot;:12,&quot;N&quot;:13,&quot;O&quot;:14,&quot;P&quot;:15,&quot;Q&quot;:16,&quot;R&quot;:17,&quot;S&quot;:18,&quot;T&quot;:19,&quot;U&quot;:20,&quot;V&quot;:21,&quot;W&quot;:22,&quot;X&quot;:23,&quot;Y&quot;:24,&quot;Z&quot;:25,&quot;a&quot;:26,&quot;b&quot;:27,&quot;c&quot;:28,&quot;d&quot;:29,&quot;e&quot;:30,&quot;f&quot;:31,&quot;g&quot;:32,&quot;h&quot;:33,&quot;i&quot;:34,&quot;j&quot;:35,&quot;k&quot;:36,&quot;l&quot;:37,&quot;m&quot;:38,&quot;n&quot;:39,&quot;o&quot;:40,&quot;p&quot;:41,&quot;q&quot;:42,&quot;r&quot;:43,&quot;s&quot;:44,&quot;t&quot;:45,&quot;u&quot;:46,&quot;v&quot;:47,&quot;w&quot;:48,&quot;x&quot;:49,&quot;y&quot;:50,&quot;z&quot;:51,&quot;0&quot;:52,&quot;1&quot;:53,&quot;2&quot;:54,&quot;3&quot;:55,&quot;4&quot;:56,&quot;5&quot;:57,&quot;6&quot;:58,&quot;7&quot;:59,&quot;8&quot;:60,&quot;9&quot;:61,&quot;+&quot;:62,&quot;&#x2F;&quot;:63};
		
	
	&#x2F;**
	 * Maps numeric values for the caps parameter of setStrokeStyle to corresponding string values.
	 * This is primarily for use with the tiny API. The mappings are as follows: 0 to &quot;butt&quot;,
	 * 1 to &quot;round&quot;, and 2 to &quot;square&quot;.
	 * For example, myGraphics.ss(16, 2) would set the line caps to &quot;square&quot;.
	 * @property STROKE_CAPS_MAP
	 * @static
	 * @final
	 * @type Array[String]
	 **&#x2F;
	Graphics.STROKE_CAPS_MAP = [&quot;butt&quot;, &quot;round&quot;, &quot;square&quot;];
	
	&#x2F;**
	 * Maps numeric values for the joints parameter of setStrokeStyle to corresponding string values.
	 * This is primarily for use with the tiny API. The mappings are as follows: 0 to &quot;miter&quot;,
	 * 1 to &quot;round&quot;, and 2 to &quot;bevel&quot;.
	 * For example, myGraphics.ss(16, 0, 2) would set the line joints to &quot;bevel&quot;.
	 * @property STROKE_JOINTS_MAP
	 * @static
	 * @final
	 * @type Array[String]
	 **&#x2F;
	Graphics.STROKE_JOINTS_MAP = [&quot;miter&quot;, &quot;round&quot;, &quot;bevel&quot;];
	
	&#x2F;**
	 * @property _ctx
	 * @static
	 * @protected
	 * @type CanvasRenderingContext2D
	 **&#x2F;
	Graphics._ctx = document.createElement(&quot;canvas&quot;).getContext(&quot;2d&quot;);
	
	&#x2F;**
	 * @property beginCmd
	 * @static
	 * @protected
	 * @type Command
	 **&#x2F;
	Graphics.beginCmd = new Command(Graphics._ctx.beginPath, [], false);
	
	&#x2F;**
	 * @property fillCmd
	 * @static
	 * @protected
	 * @type Command
	 **&#x2F;
	Graphics.fillCmd = new Command(Graphics._ctx.fill, [], false);
	
	&#x2F;**
	 * @property strokeCmd
	 * @static
	 * @protected
	 * @type Command
	 **&#x2F;
	Graphics.strokeCmd = new Command(Graphics._ctx.stroke, [], false);
	
&#x2F;&#x2F; public properties

&#x2F;&#x2F; private properties
	&#x2F;**
	 * @property _strokeInstructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._strokeInstructions = null;

	&#x2F;**
	 * @property _strokeStyleInstructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._strokeStyleInstructions = null;
	
	&#x2F;**
	 * @property _fillInstructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._fillInstructions = null;
	
	&#x2F;**
	 * @property _instructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._instructions = null;
	
	&#x2F;**
	 * @property _oldInstructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._oldInstructions = null;
	
	&#x2F;**
	 * @property _activeInstructions
	 * @protected
	 * @type Array[Command]
	 **&#x2F;
	p._activeInstructions = null;
	
	&#x2F;**
	 * @property _active
	 * @protected
	 * @type Boolean
	 * @default false
	 **&#x2F;
	p._active = false;
	
	&#x2F;**
	 * @property _dirty
	 * @protected
	 * @type Boolean
	 * @default false
	 **&#x2F;
	p._dirty = false;
	
	&#x2F;** 
	 * Initialization method.
	 * @method initialize
	 * @protected
	 * @param {String} instructions
	 **&#x2F;
	p.initialize = function() {
		this.clear();
		this._ctx = Graphics._ctx;
	}
	
	&#x2F;**
	 * Draws the display object into the specified context ignoring it&#x27;s visible, alpha, shadow, and transform.
	 * Returns true if the draw was handled (useful for overriding functionality).
	 * NOTE: This method is mainly for internal use, though it may be useful for advanced uses.
	 * @method draw
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 **&#x2F;
	p.draw = function(ctx) {
		if (this._dirty) { this._updateInstructions(); }
		var instr = this._instructions;
		for (var i=0, l=instr.length; i&lt;l; i++) {
			instr[i].exec(ctx);
		}
	}
	
	&#x2F;**
	 * Draws only the path described for this Graphics instance, skipping any
	 * non-path instructions, including fill and stroke descriptions.
	 * Used by DisplayObject.clippingPath to draw the clipping path, for example.
	 * @method drawAsPath
	 * @param {CanvasRenderingContext2D} ctx The canvas 2D context object to draw into.
	 **&#x2F;
	p.drawAsPath = function(ctx) {
		if (this._dirty) { this._updateInstructions(); }
		var instr, instrs = this._instructions;
		for (var i=0, l=instrs.length; i&lt;l; i++) {
			&#x2F;&#x2F; the first command is always a beginPath command.
			if ((instr = instrs[i]).path || i==0) { instr.exec(ctx); }
		}
	}
	
&#x2F;&#x2F; public methods that map directly to context 2D calls:
	&#x2F;**
	 * Moves the drawing point to the specified position.
	 * @method moveTo
	 * @param {Number} x The x coordinate the drawing point should move to.
	 * @param {Number} y The y coordinate the drawing point should move to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.moveTo = function(x, y) {
		this._activeInstructions.push(new Command(this._ctx.moveTo, [x, y]));
		return this;
	}
	
	&#x2F;**
	 * Draws a line from the current drawing point to the specified position, which become the new current drawing point. 
	 * For detailed information, read the 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#complex-shapes-(paths)&quot;&gt;
	 * whatwg spec&lt;&#x2F;a&gt;.
	 * @method lineTo
	 * @param {Number} x The x coordinate the drawing point should draw to.
	 * @param {Number} y The y coordinate the drawing point should draw to.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.lineTo = function(x, y) {
		this._dirty = this._active = true;
		this._activeInstructions.push(new Command(this._ctx.lineTo, [x, y]));
		return this;
	}
	
	&#x2F;**
	 * Draws an arc with the specified control points and radius.  For detailed information, read the 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#dom-context-2d-arcto&quot;&gt;
	 * whatwg spec&lt;&#x2F;a&gt;.
	 * @method arcTo
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} radius
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.arcTo = function(x1, y1, x2, y2, radius) {
		this._dirty = this._active = true;
		this._activeInstructions.push(new Command(this._ctx.arcTo, [x1, y1, x2, y2, radius]));
		return this;
	}
	
	&#x2F;**
	 * Draws an arc defined by the radius, startAngle and endAngle arguments, centered at the position (x, y). For example 
	 * arc(100, 100, 20, 0, Math.PI*2) would draw a full circle with a radius of 20 centered at (100, 100). For detailed 
	 * information, read the 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#dom-context-2d-arc&quot;&gt;whatwg spec&lt;&#x2F;a&gt;.
	 * @method arc
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} radius
	 * @param {Number} startAngle Measured in radians.
	 * @param {Number} endAngle Measured in radians.
	 * @param {Boolean} anticlockwise
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
		this._dirty = this._active = true;
		if (anticlockwise == null) { anticlockwise = false; }
		this._activeInstructions.push(new Command(this._ctx.arc, [x, y, radius, startAngle, endAngle, anticlockwise]));
		return this;
	}
	
	&#x2F;**
	 * Draws a quadratic curve from the current drawing point to (x, y) using the control point (cpx, cpy).  For detailed information, 
	 * read the &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#dom-context-2d-quadraticcurveto&quot;&gt;
	 * whatwg spec&lt;&#x2F;a&gt;.
	 * @method quadraticCurveTo
	 * @param {Number} cpx
	 * @param {Number} cpy
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.quadraticCurveTo = function(cpx, cpy, x, y) {
		this._dirty = this._active = true;
		this._activeInstructions.push(new Command(this._ctx.quadraticCurveTo, [cpx, cpy, x, y]));
		return this;
	}
	
	&#x2F;**
	 * Draws a bezier curve from the current drawing point to (x, y) using the control points (cp1x, cp1y) and (cp2x, cp2y).  
	 * For detailed information, read the 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#dom-context-2d-beziercurveto&quot;&gt;
	 * whatwg spec&lt;&#x2F;a&gt;.
	 * method @bezierCurveTo
	 * @param {Number} cp1x
	 * @param {Number} cp1y
	 * @param {Number} cp2x
	 * @param {Number} cp2y
	 * @param {Number} x
	 * @param {Number} y
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
		this._dirty = this._active = true;
		this._activeInstructions.push(new Command(this._ctx.bezierCurveTo, [cp1x, cp1y, cp2x, cp2y, x, y]));
		return this;
	}
	
	&#x2F;**
	 * Draws a rectangle at (x, y) with the specified width and height using the current fill and&#x2F;or stroke.
	 *  For detailed information, read the 
	 * &lt;a href=&quot;http:&#x2F;&#x2F;www.whatwg.org&#x2F;specs&#x2F;web-apps&#x2F;current-work&#x2F;multipage&#x2F;the-canvas-element.html#dom-context-2d-rect&quot;&gt;
	 * whatwg spec&lt;&#x2F;a&gt;.
	 * @method rect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w Width of the rectangle
	 * @param {Number} h Height of the rectangle
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.rect = function(x, y, w, h) {
		this._dirty = this._active = true;
		this._activeInstructions.push(new Command(this._ctx.rect, [x, y, w, h]));
		return this;
	}
	
	&#x2F;**
	 * Closes the current path, effectively drawing a line from the current drawing point to the first drawing point specified
	 * since the fill or stroke was last set.
	 * @method closePath
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.closePath = function() {
		if (this._active) {
			this._dirty = true;
			this._activeInstructions.push(new Command(this._ctx.closePath, []));
		}
		return this;
	}
	
	
&#x2F;&#x2F; public methods that roughly map to Flash graphics APIs:
	&#x2F;**
	 * Clears all drawing instructions, effectively reseting this Graphics instance.
	 * @method clear
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.clear = function() {
		this._instructions = [];
		this._oldInstructions = [];
		this._activeInstructions = [];
		this._strokeStyleInstructions = this._strokeInstructions = this._fillInstructions = null;
		this._active = this._dirty = false;
		return this;
	}
	
	&#x2F;**
	 * Begins a fill with the specified color. This ends the current subpath.
	 * @method beginFill
	 * @param {String} color A CSS compatible color value (ex. &quot;#FF0000&quot; or &quot;rgba(255,0,0,0.5)&quot;). Setting to null will 
	 * result in no fill.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginFill = function(color) {
		if (this._active) { this._newPath(); }
		this._fillInstructions = color ? [new Command(this._setProp, [&quot;fillStyle&quot;, color], false)] : null;
		return this;
	}
	
	&#x2F;**
	 * Begins a linear gradient fill defined by the line (x0, y0) to (x1, y1). This ends the current subpath. For example, the
	 * following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a square to display it:&lt;br&#x2F;&gt;
	 * myGraphics.beginLinearGradientFill([&quot;#000&quot;,&quot;#FFF&quot;], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 * @method beginLinearGradientFill
	 * @param {Array[String]} colors An array of CSS compatible color values. For example, [&quot;#F00&quot;,&quot;#00F&quot;] would define a gradient 
	 * drawing from red to blue.
	 * @param {Array[Number]} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw 
	 * the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param {Number} x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param {Number} y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginLinearGradientFill = function(colors, ratios, x0, y0, x1, y1) {
		if (this._active) { this._newPath(); }
		var o = this._ctx.createLinearGradient(x0, y0, x1, y1);
		for (var i=0, l=colors.length; i&lt;l; i++) {
			o.addColorStop(ratios[i], colors[i]);
		}
		this._fillInstructions = [new Command(this._setProp, [&quot;fillStyle&quot;, o], false)];
		return this;
	}
	
	&#x2F;**
	 * Begins a radial gradient fill. This ends the current subpath. For example, the following code defines a red to blue radial 
	 * gradient centered at (100, 100), with a radius of 50, and draws a circle to display it:&lt;br&#x2F;&gt;
	 * myGraphics.beginRadialGradientFill([&quot;#F00&quot;,&quot;#00F&quot;], [0, 1], 100, 100, 0, 100, 100, 50).drawCircle(100, 100, 50);
	 * @method beginRadialGradientFill
	 * @param {Array[String]} colors An array of CSS compatible color values. For example, [&quot;#F00&quot;,&quot;#00F&quot;] would define a gradient 
	 * drawing from red to blue.
	 * @param {Array[Number]} ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would 
	 * draw the first color to 10% then interpolating to the second color at 90%.
	 * @param {Number} x0 Center position of the inner circle that defines the gradient.
	 * @param {Number} y0 Center position of the inner circle that defines the gradient.
	 * @param {Number} r0 Radius of the inner circle that defines the gradient.
	 * @param {Number} x1 Center position of the outer circle that defines the gradient.
	 * @param {Number} y1 Center position of the outer circle that defines the gradient.
	 * @param {Number} r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginRadialGradientFill = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		if (this._active) { this._newPath(); }
		var o = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
		for (var i=0, l=colors.length; i&lt;l; i++) {
			o.addColorStop(ratios[i], colors[i]);
		}
		this._fillInstructions = [new Command(this._setProp, [&quot;fillStyle&quot;, o], false)];
		return this;
	}
	
	&#x2F;**
	 * Begins a pattern fill using the specified image. This ends the current subpath.
	 * @method beginBitmapFill
	 * @param image The Image, Canvas, or Video object to use as the pattern.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of &quot;repeat&quot;, &quot;repeat-x&quot;,
	 * &quot;repeat-y&quot;, or &quot;no-repeat&quot;. Defaults to &quot;repeat&quot;.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginBitmapFill = function(image, repetition) {
		if (this._active) { this._newPath(); }
		repetition = repetition || &quot;&quot;;
		var o = this._ctx.createPattern(image, repetition);
		this._fillInstructions = [new Command(this._setProp, [&quot;fillStyle&quot;, o], false)];
		return this;
	}
	
	&#x2F;**
	 * Ends the current subpath, and begins a new one with no fill. Functionally identical to beginFill(null).
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.endFill = function() {
		return this.beginFill();
	}
	
	&#x2F;**
	 * Sets the stroke style for the current subpath. Like all drawing methods, this can be chained, so you can define the stroke style and color in a single line of code like so:
	 * myGraphics.setStrokeStyle(8,&quot;round&quot;).beginStroke(&quot;#F00&quot;);
	 * @method setStrokeStyle
	 * @param thickness The width of the stroke.
	 * @param caps Optional. Indicates the type of caps to use at the end of lines. One of butt, round, or square. Defaults to &quot;butt&quot;. Also accepts the values 0 (butt), 1 (round), and 2 (square) for use with the tiny API.
	 * @param joints Optional. Specifies the type of joints that should be used where two lines meet. One of bevel, round, or miter. Defaults to &quot;miter&quot;. Also accepts the values 0 (miter), 1 (round), and 2 (bevel) for use with the tiny API.
	 * @param miter Optional. If joints is set to &quot;miter&quot;, then you can specify a miter limit ratio which controls at what point a mitered joint will be clipped.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.setStrokeStyle = function(thickness, caps, joints, miterLimit) {
		if (this._active) { this._newPath(); }
		this._strokeStyleInstructions = [
			new Command(this._setProp, [&quot;lineWidth&quot;, (thickness == null ? &quot;1&quot; : thickness)], false),
			new Command(this._setProp, [&quot;lineCap&quot;, (caps == null ? &quot;butt&quot; : (isNaN(caps) ? caps : Graphics.STROKE_CAPS_MAP[caps]))], false),
			new Command(this._setProp, [&quot;lineJoin&quot;, (joints == null ? &quot;miter&quot; : (isNaN(joints) ? joints : Graphics.STROKE_JOINTS_MAP[joints]))], false),
			new Command(this._setProp, [&quot;miterLimit&quot;, (miterLimit == null ? &quot;10&quot; : miterLimit)], false)
			];
		return this;
	}
	
	&#x2F;**
	 * Begins a stroke with the specified color. This ends the current subpath.
	 * @method beginStroke
	 * @param color A CSS compatible color value (ex. &quot;#FF0000&quot; or &quot;rgba(255,0,0,0.5)&quot;). Setting to null will result in no stroke.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginStroke = function(color) {
		if (this._active) { this._newPath(); }
		this._strokeInstructions = color ? [new Command(this._setProp, [&quot;strokeStyle&quot;, color], false)] : null;
		return this;
	}
	
	&#x2F;**
	 * Begins a linear gradient stroke defined by the line (x0, y0) to (x1, y1). This ends the current subpath. For example, the following code defines a black to white vertical gradient ranging from 20px to 120px, and draws a square to display it:&lt;br&#x2F;&gt;
	 * myGraphics.setStrokeStyle(10).beginLinearGradientStroke([&quot;#000&quot;,&quot;#FFF&quot;], [0, 1], 0, 20, 0, 120).drawRect(20, 20, 120, 120);
	 * @method beginLinearGradientStroke
	 * @param colors An array of CSS compatible color values. For example, [&quot;#F00&quot;,&quot;#00F&quot;] would define a gradient drawing from red to blue.
	 * @param ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw the first color to 10% then interpolating to the second color at 90%.
	 * @param x0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param y0 The position of the first point defining the line that defines the gradient direction and size.
	 * @param x1 The position of the second point defining the line that defines the gradient direction and size.
	 * @param y1 The position of the second point defining the line that defines the gradient direction and size.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.beginLinearGradientStroke = function(colors, ratios, x0, y0, x1, y1) {
		if (this._active) { this._newPath(); }
		var o = this._ctx.createLinearGradient(x0, y0, x1, y1);
		for (var i=0, l=colors.length; i&lt;l; i++) {
			o.addColorStop(ratios[i], colors[i]);
		}
		this._strokeInstructions = [new Command(this._setProp, [&quot;strokeStyle&quot;, o], false)];
		return this;
	}
	
	
	&#x2F;**
	 * Begins a radial gradient stroke. This ends the current subpath. For example, the following code defines a red to blue radial gradient centered at (100, 100), with a radius of 50, and draws a rectangle to display it:&lt;br&#x2F;&gt;
	 * myGraphics.setStrokeStyle(10).beginRadialGradientStroke([&quot;#F00&quot;,&quot;#00F&quot;], [0, 1], 100, 100, 0, 100, 100, 50).drawRect(50, 90, 150, 110);
	 * @method beginRadialGradientStroke
	 * @param colors An array of CSS compatible color values. For example, [&quot;#F00&quot;,&quot;#00F&quot;] would define a gradient drawing from red to blue.
	 * @param ratios An array of gradient positions which correspond to the colors. For example, [0.1, 0.9] would draw the first color to 10% then interpolating to the second color at 90%, then draw the second color to 100%.
	 * @param x0 Center position of the inner circle that defines the gradient.
	 * @param y0 Center position of the inner circle that defines the gradient.
	 * @param r0 Radius of the inner circle that defines the gradient.
	 * @param x1 Center position of the outer circle that defines the gradient.
	 * @param y1 Center position of the outer circle that defines the gradient.
	 * @param r1 Radius of the outer circle that defines the gradient.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)	
	 **&#x2F;
	p.beginRadialGradientStroke = function(colors, ratios, x0, y0, r0, x1, y1, r1) {
		if (this._active) { this._newPath(); }
		var o = this._ctx.createRadialGradient(x0, y0, r0, x1, y1, r1);
		for (var i=0, l=colors.length; i&lt;l; i++) {
			o.addColorStop(ratios[i], colors[i]);
		}
		this._strokeInstructions = [new Command(this._setProp, [&quot;strokeStyle&quot;, o], false)];
		return this;
	}
	
	&#x2F;**
	 * Begins a pattern fill using the specified image. This ends the current subpath.
	 * @method beginBitmapStroke
	 * @param {Image | HTMLCanvasElement | HTMLVideoElement} image The Image, Canvas, or Video object to use as the pattern.
	 * @param {String} repetition Optional. Indicates whether to repeat the image in the fill area. One of &quot;repeat&quot;, &quot;repeat-x&quot;,
	 * &quot;repeat-y&quot;, or &quot;no-repeat&quot;. Defaults to &quot;repeat&quot;.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)	
	 **&#x2F;
	p.beginBitmapStroke = function(image, repetition) {
		if (this._active) { this._newPath(); }
		var o = this._ctx.createPattern(image, repetition || &quot;&quot;);
		this._strokeInstructions = [new Command(this._setProp, [&quot;strokeStyle&quot;, o], false)];
		return this;
	}
	
	
	&#x2F;**
	 * Ends the current subpath, and begins a new one with no stroke. Functionally identical to beginStroke(null).
	 * @method endStroke
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.endStroke = function() {
		this.beginStroke();
		return this;
	}
	
	&#x2F;**
	 * Maps the familiar ActionScript curveTo() method to the functionally similar quatraticCurveTo() method.
	 * @property curveTo
	 * @type Function
	 **&#x2F;
	p.curveTo = p.quadraticCurveTo;
	
	&#x2F;**
	 * Maps the familiar ActionScript drawRect() method to the functionally similar rect() method.
	 * @property drawRect
	 * @type Function
	 **&#x2F;
	p.drawRect = p.rect;
	
	&#x2F;**
	 * Draws a rounded rectangle with all corners with the specified radius.
	 * @method drawRoundRect
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radius Corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.drawRoundRect = function(x, y, w, h, radius) {
		this.drawRoundRectComplex(x, y, w, h, radius, radius, radius, radius);
		return this;
	}
	
	&#x2F;**
	 * Draws a rounded rectangle with different corner radiuses.
	 * @method drawRoundRectComplex
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @param {Number} radiusTL Top left corner radius.
	 * @param {Number} radiusTR Top right corner radius.
	 * @param {Number} radiusBR Bottom right corner radius.
	 * @param {Number} radiusBL Bottom left corner radius.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.drawRoundRectComplex = function(x, y, w, h, radiusTL, radiusTR, radiusBR, radiusBL) {
		this._dirty = this._active = true;
		var pi = Math.PI, arc=this._ctx.arc, lineTo=this._ctx.lineTo;
		
		this._activeInstructions.push(
			new Command(this._ctx.moveTo, [x+radiusTL, y]),
			new Command(lineTo, [x+w-radiusTR, y]),
			(radiusTR&gt;=0) ?
				new Command(arc, [x+w-radiusTR, y+radiusTR, radiusTR, -pi&#x2F;2, 0]) :
				new Command(arc, [x+w, y, -radiusTR, pi, pi&#x2F;2, true]) ,
			new Command(lineTo, [x+w, y+h-radiusBR]),
			(radiusBL&gt;=0) ?
				new Command(arc, [x+w-radiusBR, y+h-radiusBR, radiusBR, 0, pi&#x2F;2]) :
				new Command(arc, [x+w, y+h, -radiusBR, -pi&#x2F;2, pi, true]) ,
			new Command(lineTo, [x+radiusBL, y+h]),
			(radiusBL&gt;=0) ?
				new Command(arc, [x+radiusBL, y+h-radiusBL, radiusBL, pi&#x2F;2, pi]) :
				new Command(arc, [x, y+h, -radiusBL, 0, -pi&#x2F;2, true]) ,
			new Command(lineTo, [x, y+radiusTL]),
			(radiusTL&gt;=0) ?
				new Command(arc, [x+radiusTL, y+radiusTL, radiusTL, pi, -pi&#x2F;2]) :
				new Command(arc, [x, y, -radiusTL, pi&#x2F;2, 0, true])
		);
		return this;
	} 
	
	&#x2F;**
	 * Draws a circle with the specified radius at (x, y).
	*
	 * &lt;pre&gt;&lt;code&gt;var g = new Graphics();
	*	g.setStrokeStyle(1);
	*	g.beginStroke(Graphics.getRGB(0,0,0));
	*	g.beginFill(Graphics.getRGB(255,0,0));
	*	g.drawCircle(0,0,3);
	*
	*	var s = new Shape(g);
	*		s.x = 100;
	*		s.y = 100;
	*
	*	stage.addChild(s);
	*	stage.update();&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
	 * @method drawCircle
	 * @param {Number} x x coordinate center point of circle.
	 * @param {Number} y y coordinate center point of circle.
	 * @param {Number} radius Radius of circle.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.drawCircle = function(x, y, radius) {
		this.arc(x, y, radius, 0, Math.PI*2);
		return this;
	}
	
	&#x2F;**
	 * Draws an ellipse (oval).
	 * @method drawEllipse
	 * @param {Number} x
	 * @param {Number} y
	 * @param {Number} w
	 * @param {Number} h
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.drawEllipse = function(x, y, w, h) {
		this._dirty = this._active = true;
		var k = 0.5522848;
		var ox = (w &#x2F; 2) * k;
		var oy = (h &#x2F; 2) * k;
		var xe = x + w;
		var ye = y + h;
		var xm = x + w &#x2F; 2;
		var ym = y + h &#x2F; 2;
			
		this._activeInstructions.push(
			new Command(this._ctx.moveTo, [x, ym]),
			new Command(this._ctx.bezierCurveTo, [x, ym-oy, xm-ox, y, xm, y]),
			new Command(this._ctx.bezierCurveTo, [xm+ox, y, xe, ym-oy, xe, ym]),
			new Command(this._ctx.bezierCurveTo, [xe, ym+oy, xm+ox, ye, xm, ye]),
			new Command(this._ctx.bezierCurveTo, [xm-ox, ye, x, ym+oy, x, ym])
		);
		return this;
	}
	
	&#x2F;**
	 * Draws a star if pointSize is greater than 0 or a regular polygon if pointSize is 0 with the specified number of points.
	 * For example, the following code will draw a familiar 5 pointed star shape centered at 100, 100 and with a radius of 50:
	 * myGraphics.beginFill(&quot;#FF0&quot;).drawPolyStar(100, 100, 50, 5, 0.6, -90); &#x2F;&#x2F; -90 makes the first point vertical
	 * @method drawPolyStar
	 * @param {Number} x Position of the center of the shape.
	 * @param {Number} y Position of the center of the shape.
	 * @param {Number} radius The outer radius of the shape.
	 * @param {Number} sides The number of points on the star or sides on the polygon.
	 * @param {Number} pointSize The depth or &quot;pointy-ness&quot; of the star points. A pointSize of 0 will draw a regular polygon (no points), 
	 * a pointSize of 1 will draw nothing because the points are infinitely pointy.
	 * @param {Number} angle The angle of the first point &#x2F; corner. For example a value of 0 will draw the first point directly to the 
	 * right of the center.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.drawPolyStar = function(x, y, radius, sides, pointSize, angle) {
		this._dirty = this._active = true;
		if (pointSize == null) { pointSize = 0; }
		pointSize = 1-pointSize;
		if (angle == null) { angle = 0; }
		else { angle &#x2F;= 180&#x2F;Math.PI; }
		var a = Math.PI&#x2F;sides;
		
		this._activeInstructions.push(new Command(this._ctx.moveTo, [x+Math.cos(angle)*radius, y+Math.sin(angle)*radius]));
		for (var i=0; i&lt;sides; i++) {
			angle += a;
			if (pointSize != 1) {
				this._activeInstructions.push(new Command(this._ctx.lineTo, [x+Math.cos(angle)*radius*pointSize, y+Math.sin(angle)*radius*pointSize]));
			}
			angle += a;
			this._activeInstructions.push(new Command(this._ctx.lineTo, [x+Math.cos(angle)*radius, y+Math.sin(angle)*radius]));
		}
		return this;
	}
	
	&#x2F;**
	 * Decodes a compact encoded path string into a series of draw instructions.
	 * This format is not intended to be human readable, and is meant for use by authoring tools.
	 * The format uses a base64 character set, with each character representing 6 bits, to define a series of draw commands.
	 * &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;
	 * Each command is comprised of a single &quot;header&quot; character followed by a variable number of alternating x and y position values.
	 * Reading the header bits from left to right (most to least significant): bits 1 to 3 specify the type of operation
	 * (0-moveTo, 1-lineTo, 2-quadraticCurveTo, 3-bezierCurveTo, 4-7 unused). Bit 4 indicates whether position values use 12 bits (2 characters) 
	 * or 18 bits (3 characters), with a one indicating the latter. Bits 5 and 6 are currently unused.
	 * &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;
	 * Following the header is a series of 2 (moveTo, lineTo), 4 (quadraticCurveTo), or 6 (bezierCurveTo) parameters.
	 * These parameters are alternating x&#x2F;y positions represented by 2 or 3 characters (as indicated by the 4th bit in the command char).
	 * These characters consist of a 1 bit sign (1 is negative, 0 is positive), followed by an 11 (2 char) or 17 (3 char) bit integer value.
	 * All position values are in tenths of a pixel.
	 * Except in the case of move operations, this value is a delta from the previous x or y position (as appropriate).
	 * &lt;br&#x2F;&gt;&lt;br&#x2F;&gt;
	 * For example, the string &quot;A3cAAMAu4AAA&quot; represents a line starting at -150,0 and ending at 150,0.
	 * A - bits 000000. First 3 bits (000) indicate a moveTo operation. 4th bit (0) indicates 2 chars per parameter.
	 * n0 - 110111011100. Absolute x position of -150.0px. First bit indicates a negative value, remaining bits indicate 1500 tenths of a pixel. 
	 * AA - 000000000000. Absolute y position of 0.
	 * I - 001100. First 3 bits (001) indicate a lineTo operation. 4th bit (1) indicates 3 chars per parameter.
	 * Au4 - 000000101110111000. An x delta of 300.0px, which is added to the previous x value of -150.0px to provide an absolute position of +150.0px.
	 * AAA - 000000000000000000. A y delta value of 0.
	 * 
	 * @method decodePath
	 * @param {String} str The path string to decode.
	 * @return {Graphics} The Graphics instance the method is called on (useful for chaining calls.)
	 **&#x2F;
	p.decodePath = function(str) {
		var instructions = [this.moveTo, this.lineTo, this.quadraticCurveTo, this.bezierCurveTo];
		var paramCount = [2, 2, 4, 6];
		var i=0, l=str.length;
		var params = [];
		var x=0, y=0;
		var base64 = Graphics.BASE_64;
		
		while (i&lt;l) {
			var n = base64[str.charAt(i)];
			var fi = n&gt;&gt;3; &#x2F;&#x2F; highest order bits 1-3 code for operation.
			var f = instructions[fi];
			&#x2F;&#x2F; check that we have a valid instruction &amp; that the unused bits are empty:
			if (!f || (n&amp;3)) { throw(&quot;bad path data&quot;); }
			var pl = paramCount[fi];
			if (!fi) { x=y=0; }
			params.length = 0;
			i++;
			var charCount = (n&gt;&gt;2&amp;1)+2;  &#x2F;&#x2F; 4th header bit indicates number size for this operation.
			for (var p=0; p&lt;pl; p++) {
				var num = base64[str.charAt(i)];
				var sign = (num&gt;&gt;5) ? -1 : 1;
				num = ((num&amp;31)&lt;&lt;6)|(base64[str.charAt(i+1)]);
				if (charCount == 3) { num = (num&lt;&lt;6)|(base64[str.charAt(i+2)]); }
				num = sign*num&#x2F;10;
				if (p%2) { x = (num += x); }
				else { y = (num += y); }
				params[p] = num;
				i += charCount;
			}
			f.apply(this,params);
		}
		return this;
	}
	
	&#x2F;**
	 * Returns a clone of this Graphics instance.
	 * @method clone
	 @return {Graphics} A clone of the current Graphics instance.
	 **&#x2F;
	p.clone = function() {
		var o = new Graphics();
		o._instructions = this._instructions.slice();
		o._activeInstructions = this._activeInstructions.slice();
		o._oldInstructions = this._oldInstructions.slice();
		if (this._fillInstructions) { o._fillInstructions = this._fillInstructions.slice(); }
		if (this._strokeInstructions) { o._strokeInstructions = this._strokeInstructions.slice(); }
		if (this._strokeStyleInstructions) { o._strokeStyleInstructions = this._strokeStyleInstructions.slice(); }
		o._active = this._active;
		o._dirty = this._dirty;
		o.drawAsPath = this.drawAsPath;
		return o;
	}
		
	&#x2F;**
	 * Returns a string representation of this object.
	 * @method toString
	 * @return {String} a string representation of the instance.
	 **&#x2F;
	p.toString = function() {
		return &quot;[Graphics]&quot;;
	}
	
	
&#x2F;&#x2F; tiny API:
	&#x2F;** Shortcut to moveTo.
	 * @property mt
	 * @protected
	 * type Function
	 **&#x2F;
	p.mt = p.moveTo;
	
	&#x2F;** Shortcut to lineTo.
	 * @property lt
	 * @protected
	 * type Function
	 **&#x2F;
	p.lt = p.lineTo;
	
	&#x2F;** Shortcut to arcTo.
	 * @property at
	 * @protected
	 * type Function
	 **&#x2F;
	p.at = p.arcTo;
	
	&#x2F;** Shortcut to bezierCurveTo.
	 * @property bt
	 * @protected
	 * type Function
	 **&#x2F;
	p.bt = p.bezierCurveTo;
	
	&#x2F;** Shortcut to quadraticCurveTo &#x2F; curveTo.
	 * @property qt
	 * @protected
	 * type Function
	 **&#x2F;
	p.qt = p.quadraticCurveTo;
	
	&#x2F;** Shortcut to arc.
	 * @property a
	 * @protected
	 * type Function
	 **&#x2F;
	p.a = p.arc;
	
	&#x2F;** Shortcut to rect.
	 * @property r
	 * @protected
	 * type Function
	 **&#x2F;
	p.r = p.rect;
	
	&#x2F;** Shortcut to closePath.
	 * @property cp
	 * @protected
	 * type Function
	 **&#x2F;
	p.cp = p.closePath;
	
	&#x2F;** Shortcut to clear.
	 * @property c
	 * @protected
	 * type Function
	 **&#x2F;
	p.c = p.clear;
	
	&#x2F;** Shortcut to beginFill.
	 * @property f
	 * @protected
	 * type Function
	 **&#x2F;
	p.f = p.beginFill;
	
	&#x2F;** Shortcut to beginLinearGradientFill.
	 * @property lf
	 * @protected
	 * type Function
	 **&#x2F;
	p.lf = p.beginLinearGradientFill;
	
	&#x2F;** Shortcut to beginRadialGradientFill.
	 * @property rf
	 * @protected
	 * type Function
	 **&#x2F;
	p.rf = p.beginRadialGradientFill;
	
	&#x2F;** Shortcut to beginBitmapFill.
	 * @property bf
	 * @protected
	 * type Function
	 **&#x2F;
	p.bf = p.beginBitmapFill;
	
	&#x2F;** Shortcut to endFill.
	 * @property ef
	 * @protected
	 * type Function
	 **&#x2F;
	p.ef = p.endFill;
	
	&#x2F;** Shortcut to setStrokeStyle.
	 * @property ss
	 * @protected
	 * type Function
	 **&#x2F;
	p.ss = p.setStrokeStyle;
	
	&#x2F;** Shortcut to beginStroke.
	 * @property s
	 * @protected
	 * type Function
	 **&#x2F;
	p.s = p.beginStroke;
	
	&#x2F;** Shortcut to beginLinearGradientStroke.
	 * @property ls
	 * @protected
	 * type Function
	 **&#x2F;
	p.ls = p.beginLinearGradientStroke;
	
	&#x2F;** Shortcut to beginRadialGradientStroke.
	 * @property rs
	 * @protected
	 * type Function
	 **&#x2F;
	p.rs = p.beginRadialGradientStroke;
	
	&#x2F;** Shortcut to beginBitmapStroke.
	 * @property bs
	 * @protected
	 * type Function
	 **&#x2F;
	p.bs = p.beginBitmapStroke;
	
	&#x2F;** Shortcut to endStroke.
	 * @property es
	 * @protected
	 * type Function
	 **&#x2F;
	p.es = p.endStroke;
	
	&#x2F;** Shortcut to drawRect.
	 * @property dr
	 * @protected
	 * type Function
	 **&#x2F;
	p.dr = p.drawRect;
	
	&#x2F;** Shortcut to drawRoundRect.
	 * @property rr
	 * @protected
	 * type Function
	 **&#x2F;
	p.rr = p.drawRoundRect;
	
	&#x2F;** Shortcut to drawRoundRectComplex.
	 * @property rc
	 * @protected
	 * type Function
	 **&#x2F;
	p.rc = p.drawRoundRectComplex;
	
	&#x2F;** Shortcut to drawCircle.
	 * @property dc
	 * @protected
	 * type Function
	 **&#x2F;
	p.dc = p.drawCircle;
	
	&#x2F;** Shortcut to drawEllipse.
	 * @property de
	 * @protected
	 * type Function
	 **&#x2F;
	p.de = p.drawEllipse;
	
	&#x2F;** Shortcut to drawPolyStar.
	 * @property dp
	 * @protected
	 * type Function
	 **&#x2F;
	p.dp = p.drawPolyStar;
	
	&#x2F;** Shortcut to decodePath.
	 * @property p
	 * @protected
	 * type Function
	 **&#x2F;
	p.p = p.decodePath;
	
	
&#x2F;&#x2F; private methods:
	&#x2F;**
	 * @method _updateInstructions
	 * @protected
	 **&#x2F;
	p._updateInstructions = function() {
		this._instructions = this._oldInstructions.slice();
		this._instructions.push(Graphics.beginCmd);
		 
		if (this._fillInstructions) { this._instructions.push.apply(this._instructions, this._fillInstructions); }
		if (this._strokeInstructions) {
			this._instructions.push.apply(this._instructions, this._strokeInstructions);
			if (this._strokeStyleInstructions) {
				this._instructions.push.apply(this._instructions, this._strokeStyleInstructions);
			}
		}
		
		this._instructions.push.apply(this._instructions, this._activeInstructions);
		
		if (this._fillInstructions) { this._instructions.push(Graphics.fillCmd); }
		if (this._strokeInstructions) { this._instructions.push(Graphics.strokeCmd); }
	}
	
	&#x2F;**
	 * @method _newPath
	 * @protected
	 **&#x2F;
	p._newPath = function() {
		if (this._dirty) { this._updateInstructions(); }
		this._oldInstructions = this._instructions;
		this._activeInstructions = [];
		this._active = this._dirty = false;
	}
	
	&#x2F;&#x2F; used to create Commands that set properties:
	&#x2F;**
	 * used to create Commands that set properties
	 * @method _setProp
	 * @param {String} name
	 * @param {String} value
	 * @protected
	 **&#x2F;
	p._setProp = function(name, value) {
		this[name] = value;
	}

window.Graphics = Graphics;
}(window));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
